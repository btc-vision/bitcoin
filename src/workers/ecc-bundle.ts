/**
 * Bundled @noble/secp256k1 for worker embedding.
 *
 * AUTO-GENERATED FILE - DO NOT EDIT
 * Generated by: scripts/bundle-ecc.ts
 *
 * This embeds the entire @noble/secp256k1 library as an IIFE string
 * that can be executed in a Web Worker without network requests.
 *
 * @packageDocumentation
 */

/**
 * Bundled @noble/secp256k1 library as an IIFE string.
 *
 * When executed, this creates a global `nobleSecp256k1` object with:
 * - sign(hash, privateKey, options): Create ECDSA signature
 * - schnorr.sign(hash, privateKey): Create Schnorr signature
 * - And other secp256k1 functions
 */
export const ECC_BUNDLE = "var nobleSecp256k1=(()=>{var J=Object.defineProperty;var fn=Object.getOwnPropertyDescriptor;var un=Object.getOwnPropertyNames;var ln=Object.prototype.hasOwnProperty;var yn=(t,n,e)=>n in t?J(t,n,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[n]=e;var dn=(t,n)=>{for(var e in n)J(t,e,{get:n[e],enumerable:!0})},hn=(t,n,e,s)=>{if(n&&typeof n==\"object\"||typeof n==\"function\")for(let r of un(n))!ln.call(t,r)&&r!==e&&J(t,r,{get:()=>n[r],enumerable:!(s=fn(n,r))||s.enumerable});return t};var gn=t=>hn(J({},\"__esModule\",{value:!0}),t);var V=(t,n,e)=>yn(t,typeof n!=\"symbol\"?n+\"\":n,e);var zn={};dn(zn,{Point:()=>K,Signature:()=>L,etc:()=>Rn,getPublicKey:()=>Zt,getSharedSecret:()=>Yn,hash:()=>Sn,hashes:()=>W,keygen:()=>Hn,recoverPublicKey:()=>Un,recoverPublicKeyAsync:()=>Xn,schnorr:()=>Fn,sign:()=>Tn,signAsync:()=>Nn,utils:()=>In,verify:()=>Vn,verifyAsync:()=>Zn});var Et={p:0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn,n:0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n,h:1n,a:0n,b:7n,Gx:0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n,Gy:0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n},{p:Y,n:_,Gx:pn,Gy:bn,b:Kt}=Et,p=32,R=64,j={publicKey:p+1,publicKeyUncompressed:R+1,signature:R,seed:p+p/2},xn=(...t)=>{\"captureStackTrace\"in Error&&typeof Error.captureStackTrace==\"function\"&&Error.captureStackTrace(...t)},y=(t=\"\")=>{let n=new Error(t);throw xn(n,y),n},mn=t=>typeof t==\"bigint\",wn=t=>typeof t==\"string\",An=t=>t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name===\"Uint8Array\",w=(t,n,e=\"\")=>{let s=An(t),r=t?.length,o=n!==void 0;if(!s||o&&r!==n){let i=e&&`\"${e}\" `,f=o?` of length ${n}`:\"\",u=s?`length=${r}`:`type=${typeof t}`;y(i+\"expected Uint8Array\"+f+\", got \"+u)}return t},N=t=>new Uint8Array(t),kt=(t,n)=>t.toString(16).padStart(n,\"0\"),at=t=>Array.from(w(t)).map(n=>kt(n,2)).join(\"\"),Z={_0:48,_9:57,A:65,F:70,a:97,f:102},bt=t=>{if(t>=Z._0&&t<=Z._9)return t-Z._0;if(t>=Z.A&&t<=Z.F)return t-(Z.A-10);if(t>=Z.a&&t<=Z.f)return t-(Z.a-10)},ft=t=>{let n=\"hex invalid\";if(!wn(t))return y(n);let e=t.length,s=e/2;if(e%2)return y(n);let r=N(s);for(let o=0,i=0;o<s;o++,i+=2){let f=bt(t.charCodeAt(i)),u=bt(t.charCodeAt(i+1));if(f===void 0||u===void 0)return y(n);r[o]=f*16+u}return r},_t=()=>globalThis?.crypto,xt=()=>_t()?.subtle??y(\"crypto.subtle must be defined, consider polyfill\"),E=(...t)=>{let n=N(t.reduce((s,r)=>s+w(r).length,0)),e=0;return t.forEach(s=>{n.set(s,e),e+=s.length}),n},D=(t=p)=>_t().getRandomValues(N(t)),G=BigInt,I=(t,n,e,s=\"bad number: out of range\")=>mn(t)&&n<=t&&t<e?t:y(s),c=(t,n=Y)=>{let e=t%n;return e>=0n?e:n+e},B=t=>c(t,_),$=(t,n)=>{(t===0n||n<=0n)&&y(\"no inverse n=\"+t+\" mod=\"+n);let e=c(t,n),s=n,r=0n,o=1n,i=1n,f=0n;for(;e!==0n;){let u=s/e,l=s%e,a=r-i*u,h=o-f*u;s=e,e=l,r=i,o=f,i=a,f=h}return s===1n?c(r,n):y(\"no inverse\")},nt=t=>{let n=W[t];return typeof n!=\"function\"&&y(\"hashes.\"+t+\" not set\"),n},Sn=t=>nt(\"sha256\")(t),st=t=>t instanceof K?t:y(\"Point expected\"),Tt=t=>c(c(t*t)*t+Kt),mt=t=>I(t,0n,Y),z=t=>I(t,1n,Y),rt=t=>I(t,1n,_),P=t=>(t&1n)===0n,et=t=>Uint8Array.of(t),Nt=t=>et(P(t)?2:3),Vt=t=>{let n=Tt(z(t)),e=1n;for(let s=n,r=(Y+1n)/4n;r>0n;r>>=1n)r&1n&&(e=e*s%Y),s=s*s%Y;return c(e*e)===n?e:y(\"sqrt invalid\")},T=class T{constructor(n,e,s){V(this,\"X\");V(this,\"Y\");V(this,\"Z\");this.X=mt(n),this.Y=z(e),this.Z=mt(s),Object.freeze(this)}static CURVE(){return Et}static fromAffine(n){let{x:e,y:s}=n;return e===0n&&s===0n?H:new T(e,s,1n)}static fromBytes(n){w(n);let{publicKey:e,publicKeyUncompressed:s}=j,r,o=n.length,i=n[0],f=n.subarray(1),u=C(f,0,p);if(o===e&&(i===2||i===3)){let l=Vt(u),a=P(l);P(G(i))!==a&&(l=c(-l)),r=new T(u,l,1n)}return o===s&&i===4&&(r=new T(u,C(f,p,R),1n)),r?r.assertValidity():y(\"bad point: not on curve\")}static fromHex(n){return T.fromBytes(ft(n))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}equals(n){let{X:e,Y:s,Z:r}=this,{X:o,Y:i,Z:f}=st(n),u=c(e*f),l=c(o*r),a=c(s*f),h=c(i*r);return u===l&&a===h}is0(){return this.equals(H)}negate(){return new T(this.X,c(-this.Y),this.Z)}double(){return this.add(this)}add(n){let{X:e,Y:s,Z:r}=this,{X:o,Y:i,Z:f}=st(n),u=0n,l=Kt,a=0n,h=0n,d=0n,x=c(l*3n),g=c(e*o),m=c(s*i),A=c(r*f),k=c(e+s),b=c(o+i);k=c(k*b),b=c(g+m),k=c(k-b),b=c(e+r);let S=c(o+f);return b=c(b*S),S=c(g+A),b=c(b-S),S=c(s+r),a=c(i+f),S=c(S*a),a=c(m+A),S=c(S-a),d=c(u*b),a=c(x*A),d=c(a+d),a=c(m-d),d=c(m+d),h=c(a*d),m=c(g+g),m=c(m+g),A=c(u*A),b=c(x*b),m=c(m+A),A=c(g-A),A=c(u*A),b=c(b+A),g=c(m*b),h=c(h+g),g=c(S*b),a=c(k*a),a=c(a-g),g=c(k*m),d=c(S*d),d=c(d+g),new T(a,h,d)}subtract(n){return this.add(st(n).negate())}multiply(n,e=!0){if(!e&&n===0n)return H;if(rt(n),n===1n)return this;if(this.equals(U))return qn(n).p;let s=H,r=U;for(let o=this;n>0n;o=o.double(),n>>=1n)n&1n?s=s.add(o):e&&(r=r.add(o));return s}multiplyUnsafe(n){return this.multiply(n,!1)}toAffine(){let{X:n,Y:e,Z:s}=this;if(this.equals(H))return{x:0n,y:0n};if(s===1n)return{x:n,y:e};let r=$(s,Y);return c(s*r)!==1n&&y(\"inverse invalid\"),{x:c(n*r),y:c(e*r)}}assertValidity(){let{x:n,y:e}=this.toAffine();return z(n),z(e),c(e*e)===Tt(n)?this:y(\"bad point: not on curve\")}toBytes(n=!0){let{x:e,y:s}=this.assertValidity().toAffine(),r=v(e);return n?E(Nt(s),r):E(et(4),r,v(s))}toHex(n){return at(this.toBytes(n))}};V(T,\"BASE\"),V(T,\"ZERO\");var K=T,U=new K(pn,bn,1n),H=new K(0n,1n,0n);K.BASE=U;K.ZERO=H;var ut=(t,n,e)=>U.multiply(n,!1).add(t.multiply(e,!1)).assertValidity(),X=t=>G(\"0x\"+(at(t)||\"0\")),C=(t,n,e)=>X(t.subarray(n,e)),vn=2n**256n,v=t=>ft(kt(I(t,0n,vn),R)),O=t=>{let n=X(w(t,p,\"secret key\"));return I(n,1n,_,\"invalid secret key: outside of range\")},lt=t=>t>_>>1n,Zt=(t,n=!0)=>U.multiply(O(t)).toBytes(n),Bn=t=>{try{return!!O(t)}catch{return!1}},En=(t,n)=>{let{publicKey:e,publicKeyUncompressed:s}=j;try{let r=t.length;return n===!0&&r!==e||n===!1&&r!==s?!1:!!K.fromBytes(t)}catch{return!1}},Ut=t=>{[0,1,2,3].includes(t)||y(\"recovery id must be valid and present\")},Kn=t=>{t!=null&&!wt.includes(t)&&y(`Signature format must be one of: ${wt.join(\", \")}`),t===Ht&&y('Signature format \"der\" is not supported: switch to noble-curves')},Xt=(t,n=F)=>{Kn(n);let e=j.signature,s=e+1,r=`Signature format \"${n}\" expects Uint8Array with length `;n===F&&t.length!==e&&y(r+e),n===Q&&t.length!==s&&y(r+s)},L=class t{constructor(n,e,s){V(this,\"r\");V(this,\"s\");V(this,\"recovery\");this.r=rt(n),this.s=rt(e),s!=null&&(this.recovery=s),Object.freeze(this)}static fromBytes(n,e=F){Xt(n,e);let s;e===Q&&(s=n[0],n=n.subarray(1));let r=C(n,0,p),o=C(n,p,R);return new t(r,o,s)}addRecoveryBit(n){return new t(this.r,this.s,n)}hasHighS(){return lt(this.s)}toBytes(n=F){let{r:e,s,recovery:r}=this,o=E(v(e),v(s));return n===Q?(Ut(r),E(Uint8Array.of(r),o)):o}},Yt=t=>{let n=t.length*8-256;n>1024&&y(\"msg invalid\");let e=X(t);return n>0?e>>G(n):e},yt=t=>B(Yt(w(t))),F=\"compact\",Q=\"recovered\",Ht=\"der\",wt=[F,Q,Ht],At={lowS:!0,prehash:!0,format:F,extraEntropy:!1},St=\"SHA-256\",W={hmacSha256Async:async(t,n)=>{let e=xt(),s=\"HMAC\",r=await e.importKey(\"raw\",t,{name:s,hash:{name:St}},!1,[\"sign\"]);return N(await e.sign(s,r,n))},hmacSha256:void 0,sha256Async:async t=>N(await xt().digest(St,t)),sha256:void 0},M=(t,n,e)=>(w(t,void 0,\"message\"),n.prehash?e?W.sha256Async(t):nt(\"sha256\")(t):t),Rt=N(0),It=et(0),Lt=et(1),Gt=1e3,Pt=\"drbg: tried max amount of iterations\",kn=(t,n)=>{let e=N(p),s=N(p),r=0,o=()=>{e.fill(1),s.fill(0)},i=(...a)=>nt(\"hmacSha256\")(s,E(e,...a)),f=(a=Rt)=>{s=i(It,a),e=i(),a.length!==0&&(s=i(Lt,a),e=i())},u=()=>(r++>=Gt&&y(Pt),e=i(),e);o(),f(t);let l;for(;!(l=n(u()));)f();return o(),l},_n=async(t,n)=>{let e=N(p),s=N(p),r=0,o=()=>{e.fill(1),s.fill(0)},i=(...a)=>W.hmacSha256Async(s,E(e,...a)),f=async(a=Rt)=>{s=await i(It,a),e=await i(),a.length!==0&&(s=await i(Lt,a),e=await i())},u=async()=>(r++>=Gt&&y(Pt),e=await i(),e);o(),await f(t);let l;for(;!(l=n(await u()));)await f();return o(),l},Ct=(t,n,e,s)=>{let{lowS:r,extraEntropy:o}=e,i=v,f=yt(t),u=i(f),l=O(n),a=[i(l),u];if(o!=null&&o!==!1){let g=o===!0?D(p):o;a.push(w(g,void 0,\"extraEntropy\"))}let h=E(...a),d=f;return s(h,g=>{let m=Yt(g);if(!(1n<=m&&m<_))return;let A=$(m,_),k=U.multiply(m).toAffine(),b=B(k.x);if(b===0n)return;let S=B(A*B(d+b*l));if(S===0n)return;let gt=(k.x===b?0:2)|Number(k.y&1n),pt=S;return r&&lt(S)&&(pt=B(-S),gt^=1),new L(b,pt,gt).toBytes(e.format)})},Ft=(t,n,e,s={})=>{let{lowS:r,format:o}=s;t instanceof L&&y(\"Signature must be in Uint8Array, use .toBytes()\"),Xt(t,o),w(e,void 0,\"publicKey\");try{let{r:i,s:f}=L.fromBytes(t,o),u=yt(n),l=K.fromBytes(e);if(r&&lt(f))return!1;let a=$(f,_),h=B(u*a),d=B(i*a),x=ut(l,h,d).toAffine();return B(x.x)===i}catch{return!1}},q=t=>{let n={};return Object.keys(At).forEach(e=>{n[e]=t[e]??At[e]}),n},Tn=(t,n,e={})=>(e=q(e),t=M(t,e,!1),Ct(t,n,e,kn)),Nn=async(t,n,e={})=>(e=q(e),t=await M(t,e,!0),Ct(t,n,e,_n)),Vn=(t,n,e,s={})=>(s=q(s),n=M(n,s,!1),Ft(t,n,e,s)),Zn=async(t,n,e,s={})=>(s=q(s),n=await M(n,s,!0),Ft(t,n,e,s)),Ot=(t,n)=>{let e=L.fromBytes(t,\"recovered\"),{r:s,s:r,recovery:o}=e;Ut(o);let i=yt(w(n,p)),f=o===2||o===3?s+_:s;z(f);let u=Nt(G(o)),l=E(u,v(f)),a=K.fromBytes(l),h=$(f,_),d=B(-i*h),x=B(r*h);return ut(a,d,x).toBytes()},Un=(t,n,e={})=>(n=M(n,q(e),!1),Ot(t,n)),Xn=async(t,n,e={})=>(n=await M(n,q(e),!0),Ot(t,n)),Yn=(t,n,e=!0)=>K.fromBytes(n).multiply(O(t)).toBytes(e),Mt=(t=D(j.seed))=>{w(t),(t.length<j.seed||t.length>1024)&&y(\"expected 40-1024b\");let n=c(X(t),_-1n);return v(n+1n)},qt=t=>n=>{let e=Mt(n);return{secretKey:e,publicKey:t(e)}},Hn=qt(Zt),Rn={hexToBytes:ft,bytesToHex:at,concatBytes:E,bytesToNumberBE:X,numberToBytesBE:v,mod:c,invert:$,randomBytes:D,secretKeyToScalar:O,abytes:w},In={isValidSecretKey:Bn,isValidPublicKey:En,randomSecretKey:Mt},zt=t=>Uint8Array.from(\"BIP0340/\"+t,n=>n.charCodeAt(0)),jt=\"aux\",Dt=\"nonce\",$t=\"challenge\",ct=(t,...n)=>{let e=nt(\"sha256\"),s=e(zt(t));return e(E(s,s,...n))},ot=async(t,...n)=>{let e=W.sha256Async,s=await e(zt(t));return await e(E(s,s,...n))},dt=t=>{let n=O(t),e=U.multiply(n),{x:s,y:r}=e.assertValidity().toAffine(),o=P(r)?n:B(-n),i=v(s);return{d:o,px:i}},ht=t=>B(X(t)),Wt=(...t)=>ht(ct($t,...t)),Jt=async(...t)=>ht(await ot($t,...t)),Qt=t=>dt(t).px,Ln=qt(Qt),tn=(t,n,e)=>{let{px:s,d:r}=dt(n);return{m:w(t),px:s,d:r,a:w(e,p)}},nn=t=>{let n=ht(t);n===0n&&y(\"sign failed: k is zero\");let{px:e,d:s}=dt(v(n));return{rx:e,k:s}},en=(t,n,e,s)=>E(n,v(B(t+e*s))),sn=\"invalid signature produced\",Gn=(t,n,e=D(p))=>{let{m:s,px:r,d:o,a:i}=tn(t,n,e),f=ct(jt,i),u=v(o^X(f)),l=ct(Dt,u,r,s),{rx:a,k:h}=nn(l),d=Wt(a,r,s),x=en(h,a,d,o);return cn(x,s,r)||y(sn),x},Pn=async(t,n,e=D(p))=>{let{m:s,px:r,d:o,a:i}=tn(t,n,e),f=await ot(jt,i),u=v(o^X(f)),l=await ot(Dt,u,r,s),{rx:a,k:h}=nn(l),d=await Jt(a,r,s),x=en(h,a,d,o);return await on(x,s,r)||y(sn),x},Cn=(t,n)=>t instanceof Promise?t.then(n):n(t),rn=(t,n,e,s)=>{let r=w(t,R,\"signature\"),o=w(n,void 0,\"message\"),i=w(e,p,\"publicKey\");try{let f=X(i),u=Vt(f),l=P(u)?u:c(-u),a=new K(f,l,1n).assertValidity(),h=v(a.toAffine().x),d=C(r,0,p);I(d,1n,Y);let x=C(r,p,R);I(x,1n,_);let g=E(v(d),h,o);return Cn(s(g),m=>{let{x:A,y:k}=ut(a,x,B(-m)).toAffine();return!(!P(k)||A!==d)})}catch{return!1}},cn=(t,n,e)=>rn(t,n,e,Wt),on=async(t,n,e)=>rn(t,n,e,Jt),Fn={keygen:Ln,getPublicKey:Qt,sign:Gn,verify:cn,signAsync:Pn,verifyAsync:on},tt=8,On=256,an=Math.ceil(On/tt)+1,it=2**(tt-1),Mn=()=>{let t=[],n=U,e=n;for(let s=0;s<an;s++){e=n,t.push(e);for(let r=1;r<it;r++)e=e.add(n),t.push(e);n=e.double()}return t},vt,Bt=(t,n)=>{let e=n.negate();return t?e:n},qn=t=>{let n=vt||(vt=Mn()),e=H,s=U,r=2**tt,o=r,i=G(r-1),f=G(tt);for(let u=0;u<an;u++){let l=Number(t&i);t>>=f,l>it&&(l-=o,t+=1n);let a=u*it,h=a,d=a+Math.abs(l)-1,x=u%2!==0,g=l<0;l===0?s=s.add(Bt(x,n[h])):e=e.add(Bt(g,n[d]))}return t!==0n&&y(\"invalid wnaf\"),{p:e,f:s}};return gn(zn);})();\n/*! Bundled license information:\n\n@noble/secp256k1/index.js:\n  (*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) *)\n*/\n";

/**
 * Size of the bundled code in bytes.
 */
export const ECC_BUNDLE_SIZE = 11829;
